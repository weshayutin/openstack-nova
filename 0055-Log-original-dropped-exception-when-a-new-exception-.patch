From f286a4b29d4386f8fe93f9c58fe1486f859c1317 Mon Sep 17 00:00:00 2001
From: Johannes Erdfelt <johannes.erdfelt@rackspace.com>
Date: Mon, 31 Oct 2011 15:11:36 +0000
Subject: [PATCH 55/94] Log original dropped exception when a new exception
 occurs

If a exception is caught while processing a previous exception, make sure
to log it so it doesn't silently get discarded

Cherry-picked from e2403739d5e866e011ecc45a4d5b20d5e0192997.

Change-Id: Ic887db9c2592229970737daf5dd9732b2258877b
---
 nova/compute/manager.py |   10 +---------
 nova/exception.py       |    2 ++
 nova/utils.py           |   25 +++++++++++++++++++++++++
 3 files changed, 28 insertions(+), 9 deletions(-)

diff --git a/nova/compute/manager.py b/nova/compute/manager.py
index 5feb840..69dea2e 100644
--- a/nova/compute/manager.py
+++ b/nova/compute/manager.py
@@ -464,16 +464,8 @@ class ComputeManager(manager.SchedulerDependentManager):
             # be fixed once we have no-db-messaging
             pass
         except:
-            # NOTE(sirp): 3-arg raise needed since Eventlet clears exceptions
-            # when switching between greenthreads.
-            type_, value, traceback = sys.exc_info()
-            try:
+            with utils.save_and_reraise_exception():
                 _deallocate_network()
-            finally:
-                # FIXME(sirp): when/if
-                # https://github.com/jcrocholl/pep8/pull/27 merges, we can add
-                # a per-line disable flag here for W602
-                raise type_, value, traceback
 
     @exception.wrap_exception(notifier=notifier, publisher_id=publisher_id())
     def run_instance(self, context, instance_id, **kwargs):
diff --git a/nova/exception.py b/nova/exception.py
index b88e8e5..a3992d2 100644
--- a/nova/exception.py
+++ b/nova/exception.py
@@ -92,6 +92,8 @@ def wrap_exception(notifier=None, publisher_id=None, event_type=None,
     # TODO(sandy): Find a way to import nova.notifier.api so we don't have
     # to pass it in as a parameter. Otherwise we get a cyclic import of
     # nova.notifier.api -> nova.utils -> nova.exception :(
+    # TODO(johannes): Also, it would be nice to use
+    # utils.save_and_reraise_exception() without an import loop
     def inner(f):
         def wrapped(*args, **kw):
             try:
diff --git a/nova/utils.py b/nova/utils.py
index c64b11f..4648f55 100644
--- a/nova/utils.py
+++ b/nova/utils.py
@@ -19,6 +19,7 @@
 
 """Utilities and helper functions."""
 
+import contextlib
 import datetime
 import functools
 import inspect
@@ -910,3 +911,27 @@ def convert_to_list_dict(lst, label):
     if not isinstance(lst, list):
         lst = [lst]
     return [{label: x} for x in lst]
+
+
+@contextlib.contextmanager
+def save_and_reraise_exception():
+    """Save current exception, run some code and then re-raise.
+
+    In some cases the exception context can be cleared, resulting in None
+    being attempted to be reraised after an exception handler is run. This
+    can happen when eventlet switches greenthreads or when running an
+    exception handler, code raises and catches and exception. In both
+    cases the exception context will be cleared.
+
+    To work around this, we save the exception state, run handler code, and
+    then re-raise the original exception. If another exception occurs, the
+    saved exception is logged and the new exception is reraised.
+    """
+    type_, value, traceback = sys.exc_info()
+    try:
+        yield
+    except:
+        LOG.exception(_('Original exception being dropped'),
+                      exc_info=(type_, value, traceback))
+        raise
+    raise type_, value, traceback
-- 
1.7.6.5

